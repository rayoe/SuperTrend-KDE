// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © fluxcharts

//@version=5
indicator("SuperTrend Kernel Optimized | Flux Charts ", overlay=true)

// Input Parameters
float factorInput = input.float(1.5, title="SuperTrend Factor", group="SuperTrend Settings")
int atrlengthInput = input.int(10, title="ATR Length", group="SuperTrend Settings")
float bandwidthInput = input.float(2.71828, "Bandwidth", group = "KDE", tooltip = "This setting sets the smoothness of the KDE function output.")
int stepsInput = input.int(100, "Nº Bins", minval = 1, group = "KDE", tooltip = "The number of elements the KDE Probability array will have. Higher settings will result in greater precision.")
float ActivationThresholdInput = input.float(0.6, "Activation Threshold", maxval = 1, group = "KDE", tooltip = "The threshold for the KDE function to trigger a buy or sell signal.")
string kernelInput = input.string("Gaussian", "Kernel", options=['Uniform', 'Gaussian', 'Sigmoid'], group = "KDE", tooltip = "The kernel function for KDE calculation. Gaussian is a commonly used kernel and is based on normal distribution.")
int transparencyInput1 = input.int(70, "Transparency 1", maxval = 100, minval = 0, group = "Appearance")
int transparencyInput2= input.int(95, "Transparency 2", maxval = 100, minval = 0, group = "Appearance")
color bullishcolorInput = input.color(color.green, "Bullish Color", group = "Appearance")
color bearishcolorInput = input.color(color.red, "Bearish Color", group = "Appearance")
// ATR Calculation
float atr = ta.atr(atr_len)

// @function        Used to produce an argument for the `size` parameter in built-in functions.
// @param userSize  (simple string) User-selected size.
// @returns         One of the `size.*` built-in constants.
// Dependencies     SIZE_LARGE, SIZE_NORMAL, SIZE_SMALL
SuperTrend(simple int factor, simple float atr) =>
    candle = hl2
    upperBand = candle + factor * atr
    lowerBand = candle - factor * atr
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])

    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
    int dir = na
    float supertrend = na
    prevSuperTrend = supertrend[1]
    if na(atr[1])
        dir := 1
    else if prevSuperTrend == prevUpperBand
        dir := close > upperBand ? -1 : 1
    else
        dir := close < lowerBand ? 1 : -1
    supertrend := dir == -1 ? lowerBand : upperBand  // Detect trend changes
    [supertrend, dir]

kernel(x, KDEBandwidth, kernelType) =>
    if kernelType == "Gaussian"
        math.exp(-0.5 * math.pow(x / KDEBandwidth, 2)) / (KDEBandwidth * math.sqrt(2 * math.pi))
    else if kernelType == "Uniform"
        math.abs(x) <= KDEBandwidth ? 1 / (2 * KDEBandwidth) : 0
    else if kernelType == "Sigmoid"
        1 / (1 + math.exp(-x))

kdeFunction(KDEStep, KDEBandwidth) =>
    kdeSum = 0.0
    weightSum = 0.0
    densitySum = 0.0
    float currentDensity = na
    for i = 0 to KDEStep - 1
        isPivot = (pivotUp[i] or pivotDown[i])
        if isPivot
            weight = kernel(i - (KDEStep / 2), KDEBandwidth, kernelType) // Use the Gaussian function
            kdeSum := kdeSum + close[i] * weight
            weightSum := weightSum + weight
            densitySum := densitySum + weight
            if i == 0
                currentDensity := weight  // Capture the density for the current price
    kde = kdeSum / weightSum  // KDE approximation
    [kde, currentDensity]

normalizeProbability(kdeValue, steps) =>
    meanKde = ta.sma(kdeValue, steps)  // Moving average of KDE values (mean)
    stddevKde = math.sqrt(ta.sma(math.pow(kdeValue - meanKde, 2), steps))  // Standard deviation of KDE

    // Normalize KDE using Z-Score
    zScore = (kdeValue - meanKde) / stddevKde

    // Apply Sigmoid function to map the result to a [0,1] range for other kernels
    1 / (1 + math.exp(-zScore)) // Normalize to range [0, 1]

[supertrend, dir] = SuperTrend(factor, atr)
directionChange = dir != dir[1]
pivotUp = directionChange and dir == -1 
pivotDown = directionChange and dir == 1 



[kde, currentDensity] = kdeFunction(KDEStep, KDEBandwidth)


probDensity = kernelType == "Sigmoid" ? normalizeProbability(kde, KDEStep) : normalizeProbability(kde, KDEStep)   // Apply sigmoid function to scale between 0 and 1



bool buySignal = directionChange and dir == -1 and probDensity > ActivationThreshold
bool sellSignal = directionChange and dir == 1 and probDensity > ActivationThreshold

upTrend = plot(dir == -1 ? supertrend : na, color = color.new(BULLISH_COLOR, t1), style=plot.style_linebr, title="UpTrend Line")
downTrend = plot(dir == 1 ? supertrend : na, color = color.new(BEARISH_COLOR, t1), style=plot.style_linebr, title="DownTrend Line")


bodyMiddle = plot((open + close) / 2, display=display.none, title="Candle Body Middle")

fill(bodyMiddle, upTrend, (open + close) / 2, supertrend, color.new(BULLISH_COLOR, t2), color.new(BULLISH_COLOR, t1))
fill(bodyMiddle, downTrend, supertrend, (open + close) / 2, color.new(BEARISH_COLOR, t1), color.new(BEARISH_COLOR, t2))

plotshape(buySignal, style=shape.labelup, location=location.belowbar, color=BULLISH_COLOR,text = "▲", textcolor = chart.fg_color, size=size.small, title="Buy Signal")
plotshape(sellSignal, style=shape.labeldown, location=location.abovebar, color=BEARISH_COLOR, text = "▼", textcolor = chart.fg_color ,size=size.small, title="Sell Signal")







// TODO: add user inputs and fix the code a little bit
