//@version=5
indicator("SuperTrend Kernel Optimized", overlay=true)

// Input Parameters
factor = input.float(1.5, title="Multiplier")
bandwidth = input.float(1.0, title="Bandwidth")
atr_len = input.int(10, title="ATR Length", group="SuperTrend Settings")

// ATR Calculation
atrr = ta.atr(atr_len)

// SuperTrend Function
SuperTrend(factor, atr) =>
    src = hl2
    upperBand = src + factor * atr
    lowerBand = src - factor * atr
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])

    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
    int dir = na
    float supertrend = na
    prevSuperTrend = supertrend[1]
    if na(atr[1])
        dir := 1
    else if prevSuperTrend == prevUpperBand
        dir := close > upperBand ? -1 : 1
    else
        dir := close < lowerBand ? 1 : -1
    supertrend := dir == -1 ? lowerBand : upperBand
    [supertrend, dir]


// Call SuperTrend

// Call SuperTrend
[supertrend, dir] = SuperTrend(factor, atrr)
gaussian(distance, bandwidth) =>
    math.exp(-0.5 * math.pow(distance / bandwidth, 2)) / math.sqrt(2 * math.pi)

KDE(data, bandwidth, steps) =>
    dataMin = array.min(data)
    dataMax = array.max(data)
    dataRange = dataMax - dataMin
    stepSize = dataRange / steps

    kdeX = array.new_float(steps)
    kdeY = array.new_float(steps)

    for i = 0 to steps - 1
        densityValue = dataMin + i * stepSize
        tempSum = 0.0
        for j = 0 to array.size(data) - 1
            tempSum += gaussian(densityValue - array.get(data, j), bandwidth)
        array.set(kdeX, i, densityValue)
        array.set(kdeY, i, tempSum / array.size(data))

    [kdeX, kdeY]

// Collect SuperTrend values for KDE
var superTrendValues = array.new_float()
if not na(supertrend)
    array.push(superTrendValues, supertrend)

// Compute KDE for SuperTrend
[kdeX, kdeY] = KDE(superTrendValues, 10000, 10)

// Find Distance from KDE to SuperTrend
float distance = na
float probability = na
if not na(supertrend)
    closestIndex = 0
    minDistance = 1e10
    for i = 0 to array.size(kdeX) - 1
        d = math.abs(supertrend - array.get(kdeX, i))
        if d < minDistance
            minDistance := d
            closestIndex := i
    kdeValue = array.get(kdeY, closestIndex)
    distance := minDistance
    probability := 1.0 - math.min(distance / 10000, 1.0) 

if (bar_index % 50 == 0)  // Show every 50th bar to reduce clutter
    label.new(bar_index, high, str.tostring(kdeY), color=color.white)
plot(probability, color=color.red, title="probability")

buySignal = probability > 0.9 and dir == -1
sellSignal = probability > 0.98 and dir == 1

// Plot the SuperTrend lines based on the direction
upTrend = plot(dir == -1 ? supertrend : na, color=color.green, style=plot.style_linebr, title="UpTrend Line")
downTrend = plot(dir == 1 ? supertrend : na, color=color.red, style=plot.style_linebr, title="DownTrend Line")

// Fill Areas Between Candle Body and SuperTrend Line
bodyMiddle = plot((open + close) / 2, display=display.none, title="Candle Body Middle")

fill(bodyMiddle, upTrend, (open + close) / 2, supertrend, color.green, color.new(color.green, 90))
fill(bodyMiddle, downTrend, supertrend, (open + close) / 2, color.red, color.new(color.red, 90))
plotshape(buySignal, style=shape.labelup, location=location.belowbar, color=color.green, size=size.small, title="Buy Signal")
plotshape(sellSignal, style=shape.labeldown, location=location.abovebar, color=color.red, size=size.small, title="Sell Signal")
plot(distance, color=color.blue, title="Distance to KDE")
var table realtimeTable = table.new(position.top_right, 2, 10, bgcolor = color.gray, frame_width = 2, frame_color = color.white, border_width = 1)
table.cell(realtimeTable, 1, 1, str.tostring(distance, "#"), text_color = color.white, bgcolor = color.gray)