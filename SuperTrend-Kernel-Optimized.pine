// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © fluxchart

//@version=5
indicator("SuperTrend Kernel Optimized | Flux Charts", shorttitle = "SuperTrend KDE | Flux Charts", overlay=true)

// Input Parameters
float factorInput = input.float(2, title="SuperTrend Factor", group="SuperTrend Settings", tooltip = "Multiplier for the ATR to determine the distance between the price and the SuperTrend line.")

int atrlengthInput = input.int(10, title="ATR Length", group="SuperTrend Settings", tooltip="The number of bars used to calculate the Average True Range (ATR) for the SuperTrend.")

float bandwidthInput = input.float(2, "Bandwidth", tooltip = "This setting sets the smoothness of the KDE function output.", group="KDE")

int stepsInput = input.int(100, "Bins", minval = 1, tooltip = "The number of elements the KDE Probability array will have. Higher settings will result in greater precision.", group="KDE")

string kernelInput = input.string("Gaussian", "Kernel", options=['Uniform', 'Gaussian', 'Sigmoid'], tooltip = "The kernel function for KDE calculation. Gaussian is a commonly used kernel and is based on normal distribution.", group="KDE")

float ActivationThresholdInput = input.float(60, "Activation Threshold %", maxval = 100, group = "Signal", tooltip = "The threshold for the KDE function to trigger a buy or sell signal.")

float StrongSignalThresholdInput = input.float(90, "Strong Signal Threshold %", maxval = 100, group = "Signal", tooltip = "The threshold for the KDE function to trigger a strong buy or sell signal.")

bool densityPercentage = input.bool(true, "Show Cumulative Density %", group = "Style")

int transparencyInput1 = input.int(20, "Transparency 1", maxval = 100, minval = 0, group = "Style")

int transparencyInput2= input.int(98, "Transparency 2", maxval = 100, minval = 0, group = "Style")

color bullishcolorInput = input.color(#089981, "Bullish Color", group = "Style")

color bearishcolorInput = input.color(#f23645, "Bearish Color", group = "Style")

color textColorInput = input.color(color.white, "Text Color", group="Style")


// @function        Calculates SuperTrend and detects the trend direction.
// @param factor    (float) The multiplier applied to ATR to determine the band width.
// @param atr       (float) The Average True Range (ATR) value.
// @returns         An array with two values: The SuperTrend value and the trend direction
// Dependencies     ta.atr

SuperTrend(float factor, float atr) =>
    candle = close
    upperBand = candle + factor * atr
    lowerBand = candle - factor * atr
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])

    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
    int direction = na
    float superTrend = na
    prevSuperTrend = superTrend[1]
    if na(atr[1])
        direction := 1
    else if prevSuperTrend == prevUpperBand
        direction := close > upperBand ? -1 : 1
    else
        direction := close < lowerBand ? 1 : -1
    superTrend := direction == -1 ? lowerBand : upperBand 
    directionChange = direction != direction[1] // Detect trend changes
    [superTrend, direction ,directionChange]

// @function           Kernel function for KDE calculation with selectable kernel types.
// @param steps        (float) The difference between the current value and the density range value.
// @param KDEBandwidth (float) The bandwidth parameter that controls the smoothness of the kernel.
// @param kernelType   (string) The type of kernel to use. Can be "Gaussian", "Uniform", or "Sigmoid".
// @returns            (float) The calculated kernel weight for the given value based on the selected kernel type.
// @dependencies       math.exp, math.sqrt, math.abs

kernel(steps, KDEBandwidth, kernelType) =>
    if kernelType == "Gaussian"
        math.exp(-0.5 * math.pow(steps / KDEBandwidth, 2)) / (KDEBandwidth * math.sqrt(2 * math.pi))
        
    else if kernelType == "Uniform"
        math.abs(steps) <= KDEBandwidth ? 1 / (2 * KDEBandwidth) : 0

    else if kernelType == "Sigmoid"
        1 / (1 + math.exp(-steps))


// @function           Calculates the Kernel Density Estimation (KDE) for a given set of pivots and settings.
// @param pivotArray   (array) The array of pivot values to calculate the KDE for.
// @param pivot        (bool) The pivot condition to determine the direction of the KDE calculation.
// @param KDEStep      (int) The number of steps used for the KDE calculation. Determines the resolution of the estimation.
// @param KDEBandwidth (float) The bandwidth parameter for the kernel function, controlling the smoothness of the KDE.
// @returns            (array) Returns an array with two elements: 
//                      1. `kde` (float) - The KDE approximation for the given data.
//                      2. `currentDensity` (float) - The density value for the current price level.
// @dependencies       kernel, close, pivotUp, pivotDown, math operations


kdeFunction(pivotArray, pivot, KDEStep, KDEBandwidth) =>
   
    if array.size(pivotArray) == 0
        [na, na] 

    kdeSum = 0.0
    weightSum = 0.0
    densitySum = 0.0
    float currentDensity = na

    
    startIndex = math.max(0, KDEStep / 2)
    endIndex = math.min(KDEStep - 1, bar_index)  

    for i = startIndex to endIndex
        if i >= 0 and i < array.size(pivotArray)
            isPivot = pivot[i]  
            if isPivot
                weight = kernel(i - (KDEStep / 2), KDEBandwidth, kernelInput)
                kdeSum := kdeSum + array.get(pivotArray, i) * weight
                weightSum := weightSum + weight
                densitySum := densitySum + weight
                if i == startIndex
                    currentDensity := weight  

    kde = kdeSum / weightSum  

    [kde, currentDensity]

// @function        Normalizes a given KDE value into a probability within the range [0, 1].
// @param kdeValue  (float) The current KDE value to be normalized.
// @param steps     (int) The number of steps over which the mean and standard deviation are calculated.
// @returns         (float) The normalized probability in the range [0, 1], calculated using the Z-Score and sigmoid function.
// @dependencies    ta.sma, math.sqrt, math.pow, math.exp

normalizeProbability(kdeValue, steps) =>
    meanKde = ta.sma(kdeValue, steps)  // Moving average of KDE values (mean)
    stddevKde = math.sqrt(ta.sma(math.pow(kdeValue - meanKde, 2), steps))  // Standard deviation of KDE

    // Normalize KDE using Z-Score
    zScore = (kdeValue - meanKde) / stddevKde

    // Apply Sigmoid function to map the result to a [0,1] range for other kernels
    1 / (1 + math.exp(-zScore)) // Normalize to range [0, 1]

float atr = ta.atr(atrlengthInput)

[superTrend, direction, directionChange] = SuperTrend(factorInput, atr)

pivotUp = directionChange and direction == -1 
pivotDown = directionChange and direction == 1 

var float[] upPivots = array.new_float()
var float[] downPivots = array.new_float()

if pivotUp
    array.push(upPivots, close)
if pivotDown
    array.push(downPivots, close)

[upKDE, currentDensityUp] = kdeFunction(upPivots, pivotUp, stepsInput, bandwidthInput)
[downKDE, currentDensityDown] = kdeFunction(downPivots, pivotDown, stepsInput, bandwidthInput)

upProbability = kernelInput == "Sigmoid" ? normalizeProbability(upKDE, stepsInput) : normalizeProbability(upKDE, stepsInput)   // Apply sigmoid function to scale between 0 and 1
downProbability = kernelInput == "Sigmoid" ? normalizeProbability(downKDE, stepsInput) : normalizeProbability(downKDE, stepsInput)   // Apply sigmoid function to scale between 0 and 1
// Signal
bool buySignal = directionChange and direction == -1 and upProbability > (ActivationThresholdInput/100) and  upProbability < (StrongSignalThresholdInput/100)
bool sellSignal = directionChange and direction == 1 and downProbability > (ActivationThresholdInput/100) and  downProbability < (StrongSignalThresholdInput/100)

bool strongBuySignal = directionChange and direction == -1 and upProbability > (StrongSignalThresholdInput/100)
bool strongSellSignal = directionChange and direction == 1 and downProbability > (StrongSignalThresholdInput/100)

// Style
upTrend = plot(direction == -1 ? superTrend : na, color = color.new(bullishcolorInput, transparencyInput1), style=plot.style_linebr, title="UpTrend Line")
downTrend = plot(direction == 1 ? superTrend : na, color = color.new(bearishcolorInput, transparencyInput1), style=plot.style_linebr, title="DownTrend Line")

bodyMiddle = plot((open + close) / 2, display=display.none, title="Candle Body Middle")

fill(bodyMiddle, upTrend, (open + close) / 2, superTrend, color.new(bullishcolorInput, transparencyInput2), color.new(bullishcolorInput, transparencyInput1))
fill(bodyMiddle, downTrend, superTrend, (open + close) / 2, color.new(bearishcolorInput, transparencyInput1), color.new(bearishcolorInput, transparencyInput2))

plotshape(buySignal,  style=shape.labelup, location=location.belowbar,  color=bullishcolorInput,text="▲" , textcolor = chart.fg_color, size=size.small, title="Buy Signal")
plotshape(sellSignal, style=shape.labeldown, location=location.abovebar, color=bearishcolorInput,text="▼" , textcolor = chart.fg_color ,size=size.small, title="Sell Signal")

plotshape(strongBuySignal,  style=shape.labelup, location=location.belowbar,  color=bullishcolorInput,text="▲+" , textcolor = chart.fg_color, size=size.small, title="Strong Buy Signal")
plotshape(strongSellSignal, style=shape.labeldown, location=location.abovebar, color=bearishcolorInput,text="▼+" , textcolor = chart.fg_color ,size=size.small, title="Strong Sell Signal")

string probabilityTextBear = str.tostring(downProbability*100, "#.#") + "%"
string probabilityTextBull = str.tostring(upProbability*100, "#.#") + "%"

if densityPercentage == true
    if buySignal or strongBuySignal
        label.new(bar_index, low, probabilityTextBull, color=color.new(bullishcolorInput, 100), style=label.style_label_up, textcolor=textColorInput, textalign=text.align_center, size = size.large, force_overlay=true, yloc = yloc.belowbar)
    else if sellSignal or strongSellSignal
        label.new(bar_index, high, probabilityTextBear, color=color.new(bullishcolorInput, 100), style=label.style_label_down, textcolor=textColorInput, textalign=text.align_center, size = size.large, force_overlay=true, yloc = yloc.abovebar)