//@version=5
indicator("SuperTrend Kernel Optimized", overlay=true)

// Input Parameters
factor = input.float(1.5, title="Multiplier")
atr_len = input.int(10, title="ATR Length", group="SuperTrend Settings")

// ATR Calculation
atr = ta.atr(atr_len)
bandwidth = atr * 0.5
// SuperTrend Function
SuperTrend(factor, atr) =>
    src = hl2
    upperBand = src + factor * atr
    lowerBand = src - factor * atr
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])

    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
    int dir = na
    float supertrend = na
    prevSuperTrend = supertrend[1]
    if na(atr[1])
        dir := 1
    else if prevSuperTrend == prevUpperBand
        dir := close > upperBand ? -1 : 1
    else
        dir := close < lowerBand ? 1 : -1
    supertrend := dir == -1 ? lowerBand : upperBand  // Detect trend changes
    [supertrend, dir]


// Call SuperTrend

// Call SuperTrend
[supertrend, dir] = SuperTrend(factor, atr)
directionChange = dir != dir[1]

gaussian(n, bandwidth, decay) => 
    norm = 1 / (bandwidth * math.sqrt(2 * math.pi))
    weight = norm * math.exp(-0.5 * math.pow(n / bandwidth, 2)) * math.exp(-math.abs(n) * decay)
    weight


kdeSum = 0.0
weightSum = 0.0
densitySum = 0.0
float currentDensity = na

for i = 0 to 100 - 1
    weight = gaussian(i - (100 / 2), bandwidth, 0.1)
    kdeSum := kdeSum + close[i] * weight
    weightSum := weightSum + weight
    densitySum := densitySum + weight
    if i == 0
        currentDensity := weight  // Capture the density for the current price

kde = kdeSum / weightSum  // KDE approximation
// Normalized Probability Density
maxKde = ta.highest(kde,100)  // Maximum KDE value over a period
probDensity = kde / maxKde
plot(currentDensity, color=color.red, title="Current Weight")
plot(probDensity, color=color.yellow, title="Probability Density")
// Reversal Likelihood (1 - Probability Density)
reversalLikelihood = 1 - probDensity
kdePeak = kde > kde[1] and kde > kde[2] 
kdeTrough = kde < kde[1] and kde < kde[2]
recentPeak = ta.highest(kdePeak ? kde : na, 100)  // Find recent peak
recentTrough = ta.lowest(kdeTrough ? kde : na, 100)
plot(kde)
atrThreshold = input.float(50, title="ATR Threshold")  // Adjust threshold based on asset
// Collect SuperTrend values for KDE
bool buySignal = directionChange and dir == -1 and reversalLikelihood < 0.1 and close < recentPeak
bool sellSignal = directionChange and dir == 1 and reversalLikelihood < 0.1 and close > recentTrough 
// Plot the SuperTrend lines based on the direction
upTrend = plot(dir == -1 ? supertrend : na, color=color.green, style=plot.style_linebr, title="UpTrend Line")
downTrend = plot(dir == 1 ? supertrend : na, color=color.red, style=plot.style_linebr, title="DownTrend Line")

// Fill Areas Between Candle Body and SuperTrend Line
bodyMiddle = plot((open + close) / 2, display=display.none, title="Candle Body Middle")

fill(bodyMiddle, upTrend, (open + close) / 2, supertrend, color.green, color.new(color.green, 90))
fill(bodyMiddle, downTrend, supertrend, (open + close) / 2, color.red, color.new(color.red, 90))
plotshape(buySignal, style=shape.labelup, location=location.belowbar, color=color.green,text = "▲", textcolor = chart.fg_color, size=size.small, title="Buy Signal")
plotshape(sellSignal, style=shape.labeldown, location=location.abovebar, color=color.red, text = "▼", textcolor = chart.fg_color ,size=size.small, title="Sell Signal")


// use Tether for flat price range.
// TODO: Fix signals logic and add user inputs and fix the code a little bit

// user inputs: kernel, bins, bandwidth factor, some activation threshold. colors, etc. 

// Maybe use the distance to pivot as a signal.??????


