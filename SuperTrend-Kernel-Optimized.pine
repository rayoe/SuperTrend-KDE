//@version=5
indicator("SuperTrend Kernel Optimized", overlay=true)

// Input Parameters
factor = input.float(1.5, title="Multiplier")
atr_len = input.int(10, title="ATR Length", group="SuperTrend Settings")

// ATR Calculation
atr = ta.atr(atr_len)
bandwidth = 4
// SuperTrend Function
SuperTrend(factor, atr) =>
    src = hl2
    upperBand = src + factor * atr
    lowerBand = src - factor * atr
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])

    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
    int dir = na
    float supertrend = na
    prevSuperTrend = supertrend[1]
    if na(atr[1])
        dir := 1
    else if prevSuperTrend == prevUpperBand
        dir := close > upperBand ? -1 : 1
    else
        dir := close < lowerBand ? 1 : -1
    supertrend := dir == -1 ? lowerBand : upperBand  // Detect trend changes
    [supertrend, dir]


// Call SuperTrend


// Call SuperTrend
[supertrend, dir] = SuperTrend(factor, atr)
directionChange = dir != dir[1]
pivotUp = directionChange and dir == -1 
pivotDown = directionChange and dir == 1 
gaussian(n, bandwidth, decay) => 
    norm = 1 / (bandwidth * math.sqrt(2 * math.pi))
    weight = norm * math.exp(-0.5 * math.pow(n / bandwidth, 2)) * math.exp(-math.abs(n) * decay)
    weight


kdeSum = 0.0
weightSum = 0.0
densitySum = 0.0
float currentDensity = na

for i = 0 to 1000 - 1
    isPivot = (pivotUp[i] or pivotDown[i])
    if isPivot
        weight = gaussian(i - (1000 / 2), bandwidth, 0.1)
        kdeSum := kdeSum + close[i] * weight
        weightSum := weightSum + weight
        densitySum := densitySum + weight
        if i == 0
            currentDensity := weight  // Capture the density for the current price

kde = kdeSum / weightSum  // KDE approximation
// Normalized Probability Density
minKde = ta.lowest(kde, 1000)
maxKde = ta.highest(kde, 1000)
normalizedKde = (kde - minKde) / (maxKde - minKde)  // Normalize to range [0, 1]

// Apply sigmoid with more reasonable scaling factor
sigmoid(x) =>
    1 / (1 + math.exp(-x * 10))  // Apply sigmoid with a stronger scaling factor to emphasize variance

// Calculate probability density
probDensity = sigmoid(normalizedKde)
   // Apply sigmoid function to scale between 0 and 1


plot(currentDensity, color=color.red, title="Current Weight")
plot(probDensity, color=color.yellow, title="Probability Density")
// Reversal Likelihood (1 - Probability Density)
kdePeak = kde > kde[1] and kde > kde[2] 
kdeTrough = kde < kde[1] and kde < kde[2]
recentPeak = ta.highest(kdePeak ? kde : na, 1000)  // Find recent peak
recentTrough = ta.lowest(kdeTrough ? kde : na, 1000)
plot(kde)
atrThreshold = input.float(50, title="ATR Threshold")  // Adjust threshold based on asset
// Collect SuperTrend values for KDE
bool buySignal = directionChange and dir == -1 and probDensity > 0.6 
bool sellSignal = directionChange and dir == 1 and probDensity > 0.6 
// Plot the SuperTrend lines based on the direction
upTrend = plot(    dir == -1 ? supertrend : na, color=color.green, style=plot.style_linebr, title="UpTrend Line")
downTrend = plot( dir == 1 ? supertrend : na, color=color.red, style=plot.style_linebr, title="DownTrend Line")

// Fill Areas Between Candle Body and SuperTrend Line
bodyMiddle = plot((open + close) / 2, display=display.none, title="Candle Body Middle")

fill(bodyMiddle, upTrend, (open + close) / 2, supertrend, color.green, color.new(color.green, 90))
fill(bodyMiddle, downTrend, supertrend, (open + close) / 2, color.red, color.new(color.red, 90))

plotshape(buySignal, style=shape.labelup, location=location.belowbar, color=color.green,text = "▲", textcolor = chart.fg_color, size=size.small, title="Buy Signal")
plotshape(sellSignal, style=shape.labeldown, location=location.abovebar, color=color.red, text = "▼", textcolor = chart.fg_color ,size=size.small, title="Sell Signal")




// use Tether for flat price range.
// TODO: Fix signals logic and add user inputs and fix the code a little bit

// user inputs: kernel, bins, bandwidth factor, some activation threshold. colors, etc. 
