//@version=5
indicator("SuperTrend Kernel Optimized | Flux Charts", shorttitle = "SuperTrend KDE | Flux Charts", overlay=true)


// --- SuperTrend Settings
float factorInput = input.float(3, title="SuperTrend Factor", group="SuperTrend Settings", tooltip="Multiplier for the ATR to determine the distance between the price and the SuperTrend line.")
int atrlengthInput = input.int(14, title="ATR Length", group="SuperTrend Settings", tooltip="The number of bars used to calculate the Average True Range (ATR) for the SuperTrend.")

// --- KDE Parameters
float bandwidthInput = input.float(1, title="Bandwidth", tooltip="This setting sets the smoothness of the KDE function output.", group="KDE")
int stepsInput = input.int(100, title="Bins", minval=1, tooltip="The number of elements the KDE Probability array will have. Higher settings will result in greater precision.", group="KDE")
string kernelInput = input.string("Gaussian", title="Kernel", options=["Uniform", "Gaussian", "Sigmoid"], tooltip="The kernel function for KDE calculation. Gaussian is a commonly used kernel and is based on normal distribution.", group="KDE")
int pivotLimit = input.int(300, title="Max Pivot Storage", group="KDE")

// --- Signal Thresholds
float ActivationThresholdInput = input.float(60, title="Activation Threshold %", maxval=100, group="Signal", tooltip="The threshold for the KDE function to trigger a buy or sell signal.")
float StrongSignalThresholdInput = input.float(90, title="Strong Signal Threshold %", maxval=100, group="Signal", tooltip="The threshold for the KDE function to trigger a strong buy or sell signal.")

// --- Style Settings
bool densityPercentage = input.bool(true, title="Show Cumulative Density %", group="Style")
int transparencyInput1 = input.int(20, title="Transparency 1", maxval=100, minval=0, group="Style")
int transparencyInput2 = input.int(98, title="Transparency 2", maxval=100, minval=0, group="Style")
color bullishcolorInput = input.color(color.new(#089981, 0), title="Bullish Color", group="Style")
color bearishcolorInput = input.color(color.new(#f23645, 0), title="Bearish Color", group="Style")
color textColorInput = input.color(color.white, title="Text Color", group="Style")


// @function        Calculates SuperTrend and detects the trend direction.
// @param factor    (float) The multiplier applied to ATR to determine the band width.
// @param atr       (float) The Average True Range (ATR) value.
// @returns         An array with two values: The SuperTrend value and the trend direction
// Dependencies     ta.atr
SuperTrend(float factor, float atr) =>
    float candle = close
    float upperBand = candle + factor * atr
    float lowerBand = candle - factor * atr
    float prevLowerBand = nz(lowerBand[1])
    float prevUpperBand = nz(upperBand[1])

    // Ensure bands are monotonic
    lowerBand := (lowerBand > prevLowerBand or close[1] < prevLowerBand) ? lowerBand : prevLowerBand
    upperBand := (upperBand < prevUpperBand or close[1] > prevUpperBand) ? upperBand : prevUpperBand

    int direction = na
    float superTrend = na
    float prevSuperTrend = nz(superTrend[1])

    if na(prevSuperTrend)
        direction := 1
    else if prevSuperTrend == prevUpperBand
        // If previous SuperTrend was at upperBand
        direction := (close > upperBand) ? -1 : 1
    else
        // Otherwise, it was at lowerBand
        direction := (close < lowerBand) ? 1 : -1

    superTrend := (direction == -1) ? lowerBand : upperBand
    bool directionChange = (direction != direction[1])

    [superTrend, direction, directionChange]



f_rollingWindowCleanup(float[] pivotArr, int[] barArr, int maxAgeBars) =>
    int idx = 0
    while idx < array.size(barArr)
        int pivotBar = array.get(barArr, idx)
        if (bar_index - pivotBar) > maxAgeBars
            array.remove(barArr, idx)
            array.remove(pivotArr, idx)
            // Do not increment idx because we removed the current element
        else
            idx += 1


// @function        Calculates kernel density estimation for a given set of points.
// @param distance        (float) The input value for kernel calculation.
// @param kernelType(string) The type of kernel function to use ("Gaussian", "Uniform", or "Sigmoid").
// @returns        (float) The calculated kernel density value.

f_kernel(float distance, string kernelType) =>
    if kernelType == "Gaussian"
        (1 / math.sqrt(2 * math.pi)) * math.exp(-0.5 * distance * distance)
    else if kernelType == "Uniform"
        (math.abs(distance) <= 1 ? 0.5 : 0)
    else if kernelType == "Sigmoid"
        1 / (1 + math.exp(-distance)) 
    else
        0.0


// @function        Calculates the KDE CDF for a given array of data points.
// @param arr       (array<float>) The array of data points.
// @param kernelType(string) The type of kernel to use for KDE calculation.
// @param bandwidth       (float) The bandwidth for the KDE calculation.
// @param nSteps    (int) The number of steps/bins for the KDE calculation.
// @returns         A tuple of two arrays: x values and corresponding CDF values.
f_kdeCDF(array<float> arr, string kernelType, float bandwidth, int nSteps) =>
    int n = array.size(arr)
    if n < 1
        [array.new_float(), array.new_float()]
    else
        // Determine the range of data
        float arrMin = array.min(arr)
        float arrMax = array.max(arr)
        float arrRange = arrMax - arrMin
        if arrRange == 0
            arrRange := 1e-6

        // Expand the range to capture tails and extend above the current price
        float pad = math.max(arrRange * 0.5, bandwidth* 5.0, close * 0.1)
        float xStart = arrMin - pad
        float xEnd = arrMax + pad
        // Ensure the upper bound extends well above the current price
        xEnd := math.max(xEnd, close * 1.2)

        float dx = (xEnd - xStart) / nSteps

        // Initialize arrays for x values and PDF
        float[] xArr = array.new_float(nSteps + 1, 0.0)
        float[] pdfArr = array.new_float(nSteps + 1, 0.0)

        // Compute raw PDF values over the domain
        for i = 0 to nSteps
            float xVal = xStart + i * dx
            array.set(xArr, i, xVal)
            float sumK = 0.0
            for j = 0 to n - 1
                float dataVal = array.get(arr, j)
                float distance = (xVal - dataVal) / bandwidth
                sumK += f_kernel(distance, kernelType)
            // Compute PDF value for this bin
            float pdfVal = sumK / n
            array.set(pdfArr, i, pdfVal)

        // Final area normalization to ensure total area under PDF equals 1
        float totalArea = 0.0
        for i = 0 to nSteps
            totalArea += array.get(pdfArr, i) * dx

        // Normalize PDF
        if totalArea > 0
            for i = 0 to nSteps
                float oldVal = array.get(pdfArr, i)
                array.set(pdfArr, i, oldVal / totalArea)

        // Build the CDF from the normalized PDF
        float[] cdfArr = array.new_float(nSteps + 1, 0.0)
        float running = 0.0
        for i = 0 to nSteps
            running += array.get(pdfArr, i) * dx
            array.set(cdfArr, i, running)

        [xArr, cdfArr]


// @function      Retrieves the CDF value for a given input value from the KDE CDF arrays.
// @param xArr    (float[]) The array of x values from the KDE CDF.
// @param cdfArr  (float[]) The array of CDF values corresponding to xArr.
// @param val     (float) The input value for which to retrieve the CDF value.
// @returns       The CDF value corresponding to the input value.

f_getCDF(float[] xArr, float[] cdfArr, float val) =>
    if array.size(xArr) == 0 or array.size(cdfArr) == 0
        na
    else
        // Initialize
        float closestDiff = 1e10
        int closestIdx = 0
        // Iterate to find the closest xVal
        for i = 0 to array.size(xArr) - 1
            float xVal = array.get(xArr, i)
            float diff = math.abs(xVal - val)
            if diff < closestDiff
                closestDiff := diff
                closestIdx := i
        array.get(cdfArr, closestIdx)

float atr = ta.atr(atrlengthInput)
[superTrend, direction, directionChange] = SuperTrend(factorInput, atr)
bool pivotUp = directionChange and direction == -1
bool pivotDown = directionChange and direction == 1
var float[] upPivots = array.new_float()
var float[] downPivots = array.new_float()

// Parallel arrays to track bar indices of each pivot
var int[] upPivotBars = array.new_int()
var int[] downPivotBars = array.new_int()
int rollingWindowBars = 300 // Adjust as needed
if pivotUp
    // If pivot array exceeds limit, remove the oldest pivot
    if array.size(upPivots) >= pivotLimit
        array.remove(upPivots, 0)
        array.remove(upPivotBars, 0)

    // Add new pivot
    array.push(upPivots, close)
    array.push(upPivotBars, bar_index)

    // Cleanup old pivots
    f_rollingWindowCleanup(upPivots, upPivotBars, rollingWindowBars)

if pivotDown
    if array.size(downPivots) >= pivotLimit
        array.remove(downPivots, 0)
        array.remove(downPivotBars, 0)

    // Add new pivot
    array.push(downPivots, close)
    array.push(downPivotBars, bar_index)

    // Cleanup old pivots
    // Cleanup old down pivots
    f_rollingWindowCleanup(downPivots, downPivotBars, rollingWindowBars)





bool buySignal = false
bool sellSignal = false
bool strongBuySignal = false
bool strongSellSignal = false


if pivotUp
    int sizeU = array.size(upPivots)
    if sizeU >= 3
        [xU, cdfU] = f_kdeCDF(upPivots, kernelInput, bandwidthInput, stepsInput)
        float cdfValU = f_getCDF(xU, cdfU, close)
        if not na(cdfValU)
            float thresholdSell = ActivationThresholdInput / 100.0
            float strongThresholdSell = StrongSignalThresholdInput / 100.0

            if cdfValU > strongThresholdSell
                strongBuySignal := true
            else if cdfValU > thresholdSell
                buySignal := true
            // Show CDF percentage on the chart
            if densityPercentage
                if buySignal or strongBuySignal
                    label.new(bar_index, high, str.tostring(cdfValU * 100, "#.##") + "%", color=color.new(bearishcolorInput, 100), style=label.style_label_up, textcolor=textColorInput, textalign=text.align_center, size=size.large, force_overlay=true, yloc=yloc.belowbar)


if pivotDown
    int sizeD = array.size(downPivots)
    if sizeD >= 3
        [xD, cdfD] = f_kdeCDF(downPivots, kernelInput, bandwidthInput, stepsInput)
        float cdfValD = f_getCDF(xD, cdfD, close)
        if not na(cdfValD)
            float thresholdBuy = ActivationThresholdInput / 100.0
            float strongThresholdBuy = StrongSignalThresholdInput / 100.0

            if cdfValD > strongThresholdBuy
                strongSellSignal := true
            else if cdfValD > thresholdBuy
                sellSignal := true
            // Show CDF percentage on the chart
            if densityPercentage
                if sellSignal or strongSellSignal
                    label.new(bar_index, low, str.tostring(cdfValD * 100, "#.##") + "%", color=color.new(bullishcolorInput, 100), style=label.style_label_down, textcolor=textColorInput, textalign=text.align_center, size=size.large, force_overlay=true, yloc=yloc.abovebar)


upTrend = plot(direction == -1 ? superTrend : na, color = color.new(bullishcolorInput, transparencyInput1), style=plot.style_linebr, title="UpTrend Line")
downTrend = plot(direction == 1 ? superTrend : na, color = color.new(bearishcolorInput, transparencyInput1), style=plot.style_linebr, title="DownTrend Line")

bodyMiddle = plot((open + close) / 2, display=display.none, title="Candle Body Middle")

fill(bodyMiddle, upTrend, (open + close) / 2, superTrend, color.new(bullishcolorInput, transparencyInput2), color.new(bullishcolorInput, transparencyInput1))
fill(bodyMiddle, downTrend, superTrend, (open + close) / 2, color.new(bearishcolorInput, transparencyInput1), color.new(bearishcolorInput, transparencyInput2))

plotshape(buySignal,  style=shape.labelup, location=location.belowbar,  color=bullishcolorInput,text="▲" , textcolor = chart.fg_color, size=size.small, title="Buy Signal")
plotshape(sellSignal, style=shape.labeldown, location=location.abovebar, color=bearishcolorInput,text="▼" , textcolor = chart.fg_color ,size=size.small, title="Sell Signal")

plotshape(strongBuySignal,  style=shape.labelup, location=location.belowbar,  color=bullishcolorInput,text="▲+" , textcolor = chart.fg_color, size=size.small, title="Strong Buy Signal")
plotshape(strongSellSignal, style=shape.labeldown, location=location.abovebar, color=bearishcolorInput,text="▼+" , textcolor = chart.fg_color ,size=size.small, title="Strong Sell Signal")

